<!DOCTYPE html>
<html>
	<head>
		<link rel="stylesheet" href="css/main.css" />
		<script type="text/javascript" src="scripts/perlin_noise.js"></script>
		<script type="text/javascript" src="scripts/splines.js"></script>
		<script type="text/javascript" src="scripts/matrix.js"></script>
		<script type="text/javascript" src="scripts/noise.js"></script>
		<script type="text/javascript" src="scripts/cg_shapes.js"></script>
		<script type="text/javascript" src="scripts/cg_scene.js"></script>
		<script type="text/javascript" src="scripts/cg_shader.js"></script>
		<script type="text/javascript" src="scripts/cg_main.js"></script>
		<!-- Shaders -->
		<script type="text/javascript" src="scripts/shaders/solid.js"></script>
		<script type="text/javascript" src="scripts/shaders/wire.js"></script>
		<script type="text/javascript" src="scripts/shaders/texture.js"></script>
		<script type="text/javascript" src="scripts/shaders/wirenoise.js"></script>

		<!-- Scene Initialization of each canvas -->
		<script type="text/javascript" src="canvas1.js"></script>
		<script type="text/javascript" src="canvas2.js"></script>
		<script type="text/javascript" src="canvas3.js"></script>
		<script type="text/javascript" src="canvas4.js"></script>
		<script type="text/javascript" src="canvas5.js"></script>
		<script type="text/javascript" src="canvas6.js"></script>		
		<script type="text/javascript" src="canvas7.js"></script>
		<script type="text/javascript" src="canvas8.js"></script>
	</head>
	<body>
		<section id="welcome">
			<header>Splines and Surfaces of Revolution</header>
		</section>
		<div>
			<section class="description">
				<header>B-Splines</header>
				<p>Canvas #1 shows a set of points 8 points and line segments connecting them. You can check this <a href="./scripts/shaders/wire.js" target="_blank"> file</a> to see the WebGL code I use to draw a line-strip. The file also includes the fragment and vertex shader code.</p>
				<p>Canvas #2 shows a curve C generated using "Chaikin Algorithm for B-Splines". You can find my implementation of the algorithm <a href="./scripts/splines.js" target="_blank">here</a>. I based my code on the lecture notes of Prof. Zorin [<a href="http://mrl.nyu.edu/~dzorin/intro-graphics/lectures/lecture8/sld013.htm" target="_blank">link</a>], and used as input the same 8 points used in canvas1. The figure shows the result after 3 iterations.</p> 
				
			</section>
			<section class="canvas">
				<header> canvas #1</header>
				<canvas id="canvas1" width="400", height="400"></canvas>				
			</section>
			<section class="canvas">
				<header> canvas #2</header>
				<canvas id="canvas2" width="400", height="400"></canvas>
			</section>
		</div>
		<div>
			<section id="d_canvas3" class="description">
				<header>Transformation Matrices</header>
				<p>Canvas #3 shows 30 meridians of the curve C as is revolved around the y-axis. To do this we iterate from 0 to 2*PI and  draw the same lines but with different rotation. You can see the code that generates the meridians <a href="./canvas3.js" target="_blank">here</a>, and the matrix methods <a href="./scripts/matrix.js" target="_blank">here</a>.</p>

				<p>Canvas #4 shows the meridians plus the parallels. To draw the parallels we generate a circle [<a href="./scripts/cg_shapes.js" target="_blank">code</a>]. Then for each point p of the curve C we draw the same circle, but with a transformation matrix that scales it to have radius = distance to y-axis, and translates it have y-position = p.y [<a href="./canvas4.js" target="_blank">code</a>]</p> 

				<p>Both canvas use the same vertex and fragment shader [<a href="./scripts/shaders/wire.js" target="_blank">code</a>]. The fragment shader paints the front-lines in black, and the back-lines in gray.</p>
			</section>
			<section class="canvas">
				<header> canvas #3</header>
				<canvas id="canvas3" width="400", height="400"></canvas>				
			</section>
			<section class="canvas">
				<header> canvas #4</header>
				<canvas id="canvas4" width="400", height="400"></canvas>
			</section>
		</div>
		<div>
			<section class="description">
				<header>Parametric Surface and Shading</header>
				<p>Canvas #5 shows the surface generated by revolving C around the y-axis. To generate the surface I used the code provided by Prof. Perlin to generate a parametric surface [<a href="./scripts/cg_shapes.js" target="_blank">code</a>]. I made some modifications to the code because our parametric function f is discrete in u. My parametric function is basically the same we used for the previous canvas. The parameter u moves along the points of C, and the parameter v gives the rotation angle around the y-axis [<a href="./canvas5.js" target="_blank">code</a>].</p>

				<p> The shader uses in canvas#5 is the one providing for this homeworks, and includes an implementation of phong shading.
				[<a href="./scripts/shaders/solid.js" target="_blank">code</a>]
				 </p>

				<p>Canvas #6 shows only a modification in the shader. We added diffused noise based on the the original position of the vertex (vXYZ) [<a href="./scripts/shaders/texture.js" target="_blank">code</a>]</p>
			</section>
			<section class="canvas">
				<header> canvas #5</header>
				<canvas id="canvas5" width="400", height="400"></canvas>				
			</section>
			<section class="canvas">
				<header> canvas #6</header>
				<canvas id="canvas6" width="400", height="400"></canvas>
			</section>
		</div>
		<div>
			<section class="description">
				<header>Noise Functions</header>
				<p>Canvas #7 shows the same surface but we have added noise to the x,y,z coordinates. The only modification was done on our parametric function where, after calculating x,y,z revolving the curve, I added noise to the coordinates. For this I used a javascript implementation of noise provided by Prof. Perlin [<a href="./scripts/perlin_noise.js" target="_blank">code</a>]. The cool thing of adding the noise at that point, instead on in the shader, is that the surface is generated with the correct normals :) and the shading works with no problems</p>

				<p>In contrast, for canvas #8 we added noise in the vertex-shader [<a href="./scripts/shaders/wirenoise.js" target="_blank">code</a>]. Both shader only use the position of the points, so adding the noise there is the most simple option. Another option would be to draw the meridians and the parallels with the transformed points, but it would require us to iterate over the points of C for each meridian (resp. points of the parallels). </p>
			</section>
			<section class="canvas">
				<header> canvas #7</header>
				<canvas id="canvas7" width="400", height="400"></canvas>				
			</section>
			<section class="canvas">
				<header> canvas #8</header>
				<canvas id="canvas8" width="400", height="400"></canvas>
			</section>
		</div>
		<section class="description">
			<header>Future Work</header>
			<p>For future work I would like to add and interactive canvas where the user can select the points and iterations to generate the profile curve, and on a second canvas see how the resulting surface looks.</p>
			<p>I would also like to play with revolving closed curves, and used different paths of revolution (besides circles).
		</section>
		<section class="file_tree">
			<header>Project Files</header>
			<ul>
				<li>
					<a href="./scripts">scripts/</a>
					<ul>
						<li><a href="./scripts/cg_main.js">cg_main.js</a>: basic functions for creating a webgl scene</li>
						<li><a href="./scripts/cg_scene.js">cg_scene.js</a>: functions to add objects to a scene a draw a scene</li>
						<li><a href="./scripts/cg_shader.js">cg_shader.js</a>: common functions for all shaders </li>
						<li><a href="./scripts/cg_shapes.js">cg_shapes.js</a>: functions to create surfaces and circles</li>
						<li><a href="./scripts/matrix.js">matrix.js</a>: matrix and vector functions</li>
						<li><a href="./scripts/noise.js">noise.js</a>: glsl noise implementation</li>
						<li><a href="./scripts/perlin_noise.js">perlin_noise.js</a>: js noise implementation</li>
						<li>
							<a href="./scripts/shaders/">shaders/</a>
							<ul>
								<li><a href="./scripts/shaders/solid.js">solid.js</a>: shader functions to draw solid scene</li>
								<li><a href="./scripts/shaders/texture.js">texture.js</a>: same for solid + noise</li>
								<li><a href="./scripts/shaders/wire.js">wire.js</a>: same for wire-frame scene</li>
								<li><a href="./scripts/shaders/wirenoise.js">wirenoise.js</a>: same for wire-frame + noise scene</li>
								</ul>
							</li>
						<li><a href="./scripts/splines.js">splines.js</a>: functions to create B-Splines</li>
						</ul>
				</li>
				<li><a href="./canvas1.js">canvas1.js</a>: code to create scene of canvas1</li>
				<li><a href="./canvas2.js">canvas2.js</a></li>
				<li><a href="./canvas3.js">canvas3.js</a></li>
				<li><a href="./canvas4.js">canvas4.js</a></li>
				<li><a href="./canvas5.js">canvas5.js</a></li>
				<li><a href="./canvas6.js">canvas6.js</a></li>
				<li><a href="./canvas7.js">canvas7.js</a></li>
				<li><a href="./canvas8.js">canvas8.js</a></li>
				<li>index.html: this file</li>
				<ul>
		</section>
	</body>
</html>